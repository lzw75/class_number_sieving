# gcd of any two integers (even zero).

def gcd(a, b):
   a, b = abs(a), abs(b)
   if b > a: a, b = b, a
   while b:
      a, b = b, a % b
   return a

# Test if a number n is B-smooth

def is_smooth(n, B):
   for i in range(2, B+1):
      while n % i == 0: n //= i

   return n == 1

# Check if a small number is prime.
   
def is_prime(p):
   for i in range(2, p):
      if p % i == 0: return False
      if i * i > p: return True

# Check if a large number is prime.

def is_large_prime(p):
   B = 50
   return [pow(i+2, p-1, p) for i in range(B)] == [1] * B
      
# Check if a mod p is a square, p = odd prime.
      
def is_square_mod(a, p):
   if p == 2: return True
   return pow(a, (p-1)//2, p) == 1

# Compute sqrt mod p, p = odd prime.
   
def tonelli(n, p):
   assert is_square_mod(n, p) == 1, "not a square (mod p)"
   q = p - 1
   s = 0
   while q % 2 == 0:
      q //= 2
      s += 1
   if s == 1:
      return pow(n, (p + 1) // 4, p)
   for z in range(2, p):
      if not is_square_mod(z, p):
         break
   c = pow(z, q, p)
   r = pow(n, (q + 1) // 2, p)
   t = pow(n, q, p)
   m = s
   t2 = 0
   while (t - 1) % p != 0:
      t2 = (t * t) % p
      for i in range(1, m):
         if (t2 - 1) % p == 0:
            break
         t2 = (t2 * t2) % p
      b = pow(c, 1 << (m - i - 1), p)
      r = (r * b) % p
      c = (b * b) % p
      t = (t * c) % p
      m = i
   
   return r


# For simplicity, stick to m prime of 3 mod 8, so that 2 is inert.
   
# m = 2000003
# B = 85
# rel_range = 800

m = 100000123
B = 1000
rel_range = 4000

assert is_large_prime(m), "m is not prime"
assert B < m, "base is too large"
assert m % 8 == 3, "m must be 3 mod 8"


# Check whether a + b sqrt(-m) is in prime ideal generated by p and t + sqrt(-m).
# In quotient Z[sqrt(-m)]/(p, t + sqrt(-m)), the field is F_p, with sqrt(-m) -> -t.
# Hence a + b sqrt(-m) lies in the ideal <=> a - bt = 0 mod p.

def in_prime_ideal(a, b, p, t):
   return (a - b * t) % p == 0


# List of prime ideals. Each prime ideal is stored as [p, t],
# where the ideal is generated by p and t + sqrt(-m).
# The case p=2 is handled separately.

prime_ideals = []
num_primes = 0

for p in range(3, B):
   if not is_prime(p): continue
   if is_square_mod(-m, p):
      t = tonelli(-m, p)
      t = min(t, p-t)
      prime_ideals.append([p, t])
      prime_ideals.append([p, p-t])
      num_primes += 1
      
for [p, t] in prime_ideals:
   print("Prime ideal generated by %d and %d + sqrt(-m)" % (p, t))
   assert((t*t + m) % p == 0)      

print("---")   



# Find relations. 

relations = []

for i in range(rel_range):
   norm = m + i*i
   if is_smooth(norm, B): 
      print("%d + sqrt(-m) is smooth." % i)
      new_relation = [0] * num_primes
      
      for j, [p, t] in enumerate(prime_ideals):
         pwr = 0
         if in_prime_ideal(i, 1, p, t):
            assert norm % p == 0
            while norm % p == 0:
               norm //= p
               pwr += 1
               
            if j % 2 == 1: pwr = -pwr
            new_relation[j//2] = pwr
            #print("%d %d" % (j, pwr))
      
      relations.append(new_relation)
            
      # Since m is 3 mod 8, highest power of 2 dividing m + i*i is either 1 or 4.
      
      assert norm == 1 or norm == 4, "Error norm = %d" % norm

      
# Print out the matrix.

for r in relations: print(r)

num_relations = len(relations)

assert num_relations > num_primes + 1, "Not enough relations!"

# Compute determinant with numpy (lazy!)
   
import numpy as np

matrix = np.array(relations)

assert np.linalg.matrix_rank(matrix) == num_primes, "Not full rank matrix!"

g = 0

for i in range(10):
   new_matrix = np.random.permutation(matrix)
   tgt_rows = []
   k = 0
   for j in range(1, num_primes+1):
      while True:
         new_tgt_rows = tgt_rows + [k]
         tgt_matrix = new_matrix[new_tgt_rows, :]
         k += 1
         if np.linalg.matrix_rank(tgt_matrix) == j: break
         
      tgt_rows = new_tgt_rows
   
   tgt_matrix = new_matrix[tgt_rows, :]
   t = int(abs(np.linalg.det(tgt_matrix)) + 0.5)
   
   if t:
      print(t)
      g = gcd(g, t)

print("Class number of field Q(sqrt(-%d)) = %d" % (m, g))
print("Class number of ring Z[sqrt(-%d)] = %d" % (m, 3*g))

